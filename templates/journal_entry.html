{% extends "layout.html" %}

{% block title %}Journal Entry{% endblock %}

{% block styles %}
<!-- Badge notification styles -->
<style>

.reflection-prompt-box {
    background-color: #f8f9fa;
    border-left: 3px solid #17a2b8;
    padding: 10px 15px;
    border-radius: 4px;
    font-style: italic;
}

/* Animation for new messages */
@keyframes messageAppear {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.chat-message {
    animation: messageAppear 0.3s ease-out;
}

@keyframes badgeEarned {
    0% {
        transform: scale(0.7);
        opacity: 0;
    }
    60% {
        transform: scale(1.1);
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

.badge-animation {
    animation: badgeEarned 1s ease-out;
}

.neuroscience-fact {
    animation: fadeIn 1.5s ease-in;
}

@keyframes fadeIn {
    0% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}

/* Styling for initial insight sections */
.validation-section {
    border-left: 4px solid #6c757d;
    padding-left: 15px;
    margin-bottom: 20px;
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    color: #212529;
}

.thought-patterns-section {
    border-left: 4px solid #dc3545;
    padding-left: 15px;
    margin-bottom: 20px;
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    color: #212529;
}

.strategies-section {
    border-left: 4px solid #28a745;
    padding-left: 15px;
    margin-bottom: 20px;
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    color: #212529;
}

.reflection-section {
    border-left: 4px solid #17a2b8;
    padding-left: 15px;
    margin-bottom: 20px;
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    color: #212529;
}

.closing-section {
    font-style: italic;
    margin-top: 20px;
    color: #6c757d;
}

.paragraph {
    margin-bottom: 15px;
    color: #212529;
}

/* Ensure all text in the insights has proper contrast */
.initial-insight, .followup-insight, .closing-message {
    color: #212529;
}

.initial-insight h5, .followup-insight h5, .closing-message h5 {
    color: #212529;
    font-weight: 600;
}

/* Fix any background/text contrast issues in insight cards */
#initial-insight-card, #followup-card, #reflection-card, #second-reflection-card, #closing-card {
    background-color: #ffffff;
}

#initial-insight-card .card-body, #followup-card .card-body, 
#reflection-card .card-body, #second-reflection-card .card-body, 
#closing-card .card-body {
    background-color: #ffffff;
    color: #212529;
}

/* Fix any thought pattern display issue from the screenshot */
.thought-patterns-section, .validation-section, .strategies-section, .reflection-section {
    color: #212529 !important;
    background-color: #f8f9fa !important;
}

/* Tab styles */
.nav-tabs .nav-link.active, .nav-tabs .nav-link:focus {
    background-color: #007bff;
    color: white;
    border-bottom: 2px solid #007bff;
}

.nav-tabs .nav-link {
    border: 1px solid #ced4da;
    border-bottom: 1px solid transparent;
    border-radius: 0.25rem 0.25rem 0 0;
}

.tab-content {
  border: 1px solid #dee2e6;
  border-top: 0;
  border-radius: 0 0 0.25rem 0.25rem;
}

.template-card {
  border: 1px solid #dee2e6;
  padding: 15px;
  border-radius: 5px;
  background-color: #f8f9fa;
  margin-bottom: 10px;
}

.cbt-section {
  margin-bottom: 20px;
  border: 1px solid #dee2e6;
  padding: 15px;
  border-radius: 5px;
}

.cbt-section h5 {
  border-bottom: 1px solid #dee2e6;
  padding-bottom: 10px;
  margin-bottom: 10px;
}

.insight-text {
    font-style: italic;
    color: #495057;
}

.reflection-prompt {
    font-style: italic;
    color: #495057;
}

.signature {
    text-align: right;
    font-style: italic;
    color: #6c757d;
}

</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
  <div class="row">
    <div class="col-md-12">
      {% if not view_only %}
      <div class="card mb-4">
        <div class="card-body">
          <form method="POST" id="journal-form">
            {{ form.hidden_tag() }}
            <div class="mb-3">
              {{ form.title.label(class="form-label") }}
              {{ form.title(class="form-control", autofocus=true) }}
            </div>
            <div class="mb-3">
              {{ form.content.label(class="form-label") }}
              {{ form.content(class="form-control", rows="6") }}
            </div>
            <div class="mb-3">
              {{ form.anxiety_level.label(class="form-label") }}
              <input type="range" class="form-range" min="1" max="10" id="anxiety-slider" oninput="updateAnxietyLabel(this.value)">
              <div class="text-center mt-2">
                Level: <span id="anxiety-value" class="badge bg-primary">5</span>
                {{ form.anxiety_level(id="anxiety-input", style="display: none;") }}
              </div>
            </div>
            <div class="d-grid">
              {{ form.submit(class="btn btn-primary", id="journal-submit-button") }}
            </div>
          </form>
        </div>
      </div>
      {% endif %}

      <ul class="nav nav-tabs" id="insightTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="listen-tab" data-bs-toggle="tab" data-bs-target="#listen" type="button" role="tab">
            Mira's Insights (Listen)
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="interact-tab" data-bs-toggle="tab" data-bs-target="#interact" type="button" role="tab">
            CBT Tools & Prompts (Interact)
          </button>
        </li>
      </ul>

      <div class="tab-content mt-3" id="insightTabContent">
        <!-- Listen Tab -->
        <div class="tab-pane fade show active" id="listen" role="tabpanel">
          <div class="card">
            <div class="card-body">
              <h4 class="card-title">Conversation with Mira</h4>

              <!-- Chat Container - This div is used by reflection-handler.js to append new messages -->
              <div class="chat-container">

              <!-- User's Journal Entry (Speech Bubble) -->
              <div class="chat-message user-message mb-4">
                <div class="d-flex">
                  <div class="chat-avatar me-3">
                    <div class="chat-avatar-circle bg-primary text-white">
                      <span>{{ current_user.username[0].upper() }}</span>
                    </div>
                  </div>
                  <div class="chat-bubble user-bubble">
                    <div class="chat-content">
                      <h6 class="mb-1">{{ entry.title }}</h6>
                      <p class="mb-0">{{ entry.content | nl2br }}</p>
                      <div class="chat-info small text-muted mt-1">
                        <span>{{ entry.created_at.strftime('%b %d, %Y at %I:%M %p') }}</span>
                        <span class="ms-2">Anxiety Level: {{ entry.anxiety_level }}/10</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Mira's Response (Speech Bubble) -->
              <div class="chat-message mira-message mb-4">
                <div class="d-flex">
                  <div class="chat-avatar me-3">
                    <div class="chat-avatar-circle bg-info text-white">
                      <span>M</span>
                    </div>
                  </div>
                  <div class="chat-bubble mira-bubble">
                    <div class="chat-content" style="color: #000000 !important;">
                      {% if structured_data.narrative_response %}
                        <div class="mb-3" style="color: #000000 !important;">
                          <div class="d-flex justify-content-between align-items-start">
                            <p class="mb-0 flex-grow-1" style="color: #000000 !important;">{{ structured_data.narrative_response | safe }}</p>
                            <button class="btn btn-sm btn-outline-primary ms-2 mira-tts-button" title="Listen to Mira's response">
                              <i class="bi bi-volume-up"></i>
                            </button>
                          </div>
                        </div>
                      {% else %}
                        <!-- Extract only the main message part without thought pattern section -->
                        {% set insight_text = structured_data.insight_text %}
                        {% if "We're starting to notice" in insight_text %}
                          {% set insight_text = insight_text.split("We're starting to notice")[0] %}
                        {% endif %}
                        <p class="mb-3" style="color: #000000 !important;">{{ insight_text | safe }}</p>

                        <div class="reflection-prompt-box mt-3 mb-3" style="color: #000000 !important;">
                          <div class="d-flex justify-content-between align-items-center">
                            <p class="reflection-prompt mb-0 flex-grow-1" style="color: #000000 !important;">{{ structured_data.reflection_prompt | safe }}</p>
                            <button class="btn btn-sm btn-outline-primary ms-2 mira-tts-button" title="Listen to Mira's question">
                              <i class="bi bi-volume-up"></i>
                            </button>
                          </div>
                        </div>
                      {% endif %}

                      <audio id="serverAudio" controls style="display: none; width: 100%; margin-top: 10px;"></audio>

                      <div class="chat-info text-end small text-muted mt-2">
                        <span>Coach Mira</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- User's Reflection Area (Automatically Displayed) -->
              <div class="reflection-form" data-entry-id="{{ entry.id }}">
                <div class="chat-message user-reflection-message mb-4">
                  <div class="d-flex">
                    <div class="chat-avatar me-3">
                      <div class="chat-avatar-circle bg-primary text-white">
                        <span>{{ current_user.username[0].upper() }}</span>
                      </div>
                    </div>
                    <div class="chat-bubble user-bubble">
                      <div class="chat-content">
                        <textarea class="form-control reflection-input" rows="3" 
                                 placeholder="Share your thoughts on Mira's reflection prompt..."></textarea>
                        <div class="d-flex justify-content-end mt-2">
                          <button class="btn btn-sm btn-outline-secondary me-2 cancel-reflection">Cancel</button>
                          <button class="btn btn-sm btn-primary submit-reflection">Submit Reflection</button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Display Saved User Reflection If Available -->
              {% if entry.user_reflection %}
              <div class="chat-message user-message mb-4">
                <div class="d-flex">
                  <div class="chat-avatar me-3">
                    <div class="chat-avatar-circle bg-primary text-white">
                      <span>{{ current_user.username[0].upper() }}</span>
                    </div>
                  </div>
                  <div class="chat-bubble user-bubble">
                    <div class="chat-content">
                      <p class="mb-0">{{ entry.user_reflection | nl2br }}</p>
                      <div class="chat-info small text-muted mt-1">
                        <span>Your reflection</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              {% endif %}

              <!-- Mira's Follow-up Response If Available -->
              {% if structured_data.followup_text %}
              <div class="chat-message mira-message mb-4">
                <div class="d-flex">
                  <div class="chat-avatar me-3">
                    <div class="chat-avatar-circle bg-info text-white">
                      <span>M</span>
                    </div>
                  </div>
                  <div class="chat-bubble mira-bubble">
                    <div class="chat-content" style="color: #000000 !important;">
                      <div style="color: #000000 !important;">
                        <div class="d-flex justify-content-between align-items-start">
                          {% set followup_text = structured_data.followup_text %}
                          {% if "We're starting to notice" in followup_text %}
                            {% set followup_text = followup_text.split("We're starting to notice")[0] %}
                          {% endif %}
                          <p class="mb-0 flex-grow-1" style="color: #000000 !important;">{{ followup_text | safe }}</p>
                          <button class="btn btn-sm btn-outline-primary ms-2 followup-tts-button" title="Listen to Mira's followup">
                            <i class="bi bi-volume-up"></i>
                          </button>
                        </div>
                      </div>
                      <div class="chat-info text-end small text-muted mt-2">
                        <span>Coach Mira</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              {% endif %}

              </div> <!-- End of chat-container -->
            </div>
          </div>
        </div>

        <!-- Interact Tab -->
        <div class="tab-pane fade" id="interact" role="tabpanel">
          <div class="card">
            <div class="card-body" style="color: #000000 !important;">
              {% if structured_data.distortions %}
              <div class="cbt-section">
                <h5>Thought Patterns</h5>
                <ul class="list-unstyled">
                  {% for distortion in structured_data.distortions %}
                  <li class="mb-2"><strong>{{ distortion.pattern }}</strong>: {{ distortion.description | safe }}</li>
                  {% endfor %}
                </ul>
              </div>
              {% endif %}

              {% if structured_data.strategies %}
              <div class="cbt-section mt-4">
                <h5>Strategies</h5>
                <ul class="list-unstyled">
                  {% for strategy in structured_data.strategies %}
                  <li class="mb-2">{{ strategy.title | safe }}: {{ strategy.description | safe }}
                    {% if strategy.action_step %}
                    <div class="action-step mt-2">
                        <strong class="text-dark" style="background-color: #f0f0f0; padding: 2px 5px; border-radius: 3px; display: inline-block;">Try this:</strong> {{ strategy.action_step | safe }}
                    </div>
                    {% endif %}
                  </li>
                  {% endfor %}
                </ul>
              </div>
              {% endif %}

              {% if structured_data.actionable_templates %}
              <div class="cbt-section mt-4">
                <h5>Communication Templates</h5>
                {% for template in structured_data.actionable_templates %}
                <div class="template-card mb-3">
                  <p class="mb-2"><em>"{{ template.template | safe }}"</em></p>
                  {% if template.follow_up_guidance %}
                  <div class="guidance mt-2">
                    <p class="small mb-0"><strong>Then:</strong> {{ template.follow_up_guidance | safe }}</p>
                  </div>
                  {% endif %}
                </div>
                {% endfor %}
              </div>
              {% endif %}

              {% if structured_data.relationship_exploration %}
              <div class="cbt-section mt-4">
                <h5>Relationship Context Questions</h5>
                <ul class="list-unstyled">
                  {% for question in structured_data.relationship_exploration %}
                  <li class="mb-2"><strong>{{ question.question | safe }}</strong>
                    {% if question.purpose %}
                    <p class="text-muted small mb-0 mt-1">{{ question.purpose | safe }}</p>
                    {% endif %}
                  </li>
                  {% endfor %}
                </ul>
              </div>
              {% endif %}

              {% if structured_data.followup_text %}
              <div class="mt-4">
                <p class="followup-text">{{ structured_data.followup_text | safe }}</p>
              </div>
              {% endif %}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% if entry and (not entry.is_analyzed or not entry.initial_insight) and not (structured_data and structured_data.insight_text) %}
<div class="container mt-4">
    <div class="row">
        <div class="col-lg-8 mx-auto">
            <div class="card shadow" id="analyze-card">
                <div class="card-header bg-info text-white">
                    <h3 class="mb-0">Ready for Analysis</h3>
                </div>
                <div class="card-body text-center">
                    <p>Your entry hasn't been analyzed yet. Would you like Mira to help identify thought patterns and suggest coping strategies?</p>
                    <button class="btn btn-primary" id="analyze-entry" data-journal-id="{% if entry %}{{ entry.id }}{% endif %}">
                        <i class="bi bi-lightbulb"></i> 
                        Analyze My Entry
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endif %}

<!-- Additional information -->
<div class="container mt-4 mb-5">
    <div class="row">
        <div class="col-lg-8 mx-auto">
            <div class="card shadow">
                <div class="card-header" style="background-color: #6c757d; color: white;">
                    <h3 class="mb-0">About Journal Analysis</h3>
                </div>
                <div class="card-body">
                    <p>The AI analysis helps identify thought patterns from cognitive behavioral therapy (CBT) and suggests personalized coping strategies. Your data is private and secure.</p>

                    <h5 class="mt-3">Common Thought Patterns:</h5>
                    <ul>
                        <li><strong>Catastrophizing:</strong> Assuming the worst will happen</li>
                        <li><strong>Black-and-White Thinking:</strong> Viewing things as all good or all bad</li>
                        <li><strong>Overgeneralization:</strong> Applying one negative experience to all situations</li>
                        <li><strong>Mind Reading:</strong> Assuming you know what others are thinking</li>
                        <li><strong>Emotional Reasoning:</strong> Believing feelings reflect reality</li>
                    </ul>

                    <p class="text-info mt-3">
                        <i class="bi bi-info-circle"></i> 
                        Analysis takes about 5-10 seconds to complete.
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- Voice Settings Modal -->
<div class="modal fade" id="voiceSettingsModal" tabindex="-1" aria-labelledby="voiceSettingsModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header" style="background-color: #f8f9fa; border-bottom: 2px solid #e9ecef;">
        <h5 class="modal-title" id="voiceSettingsModalLabel">
          <i class="bi bi-soundwave text-primary me-2"></i>Voice Settings
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <div class="d-flex align-items-center mb-3">
            <span style="background-color: #10a37f; color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold;">OpenAI</span>
            <h6 class="ms-2 mb-0 fw-bold">Select Neural Voice</h6>
          </div>
          <p class="text-muted small mb-3">Choose the voice that best reflects the tone you'd like to hear from Mira. Each voice has a distinct personality and speaking style.</p>
          <div class="voice-options" id="openai-voice-options">
            <!-- Voice cards will be filled in dynamically -->
          </div>
        </div>
        <div class="mt-4 p-3 bg-light rounded">
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="autoplayToggle">
            <label class="form-check-label" for="autoplayToggle">
              <strong>Automatically play voice</strong> for new insights
            </label>
          </div>
        </div>
        <div class="alert alert-info small mt-3">
          <i class="bi bi-info-circle me-2"></i> These neural voices use OpenAI's advanced technology for human-like speech. Your selection will be remembered for future sessions.
        </div>
      </div>
      <div class="modal-footer" style="background-color: #f8f9fa; border-top: 2px solid #e9ecef;">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">
          <i class="bi bi-x-circle me-1"></i>Cancel
        </button>
        <button type="button" class="btn btn-primary" id="saveVoiceSettings">
          <i class="bi bi-check-circle me-1"></i>Save Voice Settings
        </button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Include reflection handler for conversational UI -->
<script src="{{ url_for('static', filename='js/reflection-handler.js') }}"></script>
<script>
    // Reflection Area Functionality
    document.addEventListener('DOMContentLoaded', function() {
        // Auto-focus the reflection input field when the page loads
        const reflectionForm = document.querySelector('.reflection-form');

        if (reflectionForm) {
            const reflectionInput = reflectionForm.querySelector('.reflection-input');
            if (reflectionInput) {
                reflectionInput.focus();
            }
            // Scroll to the reflection area
            reflectionForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // The rest of the reflection functionality is now handled in reflection-handler.js
    });

    // Voice input functionality
    function setupVoiceInput() {
        const voiceButton = document.getElementById('voice-input-button');
        const journalContent = document.getElementById('journal-content');
        const statusDiv = document.getElementById('voice-input-status');
        const statusText = document.getElementById('voice-status-text');

        // Check if browser supports speech recognition
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
            // Hide the voice input button if speech recognition isn't supported
            if (voiceButton) {
                voiceButton.style.display = 'none';
            }
            console.log('Speech recognition not supported in this browser');
            return;
        }

        // Initialize speech recognition
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();

        // Configure recognition
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US'; // Default to English

        let isListening = false;
        let finalTranscript = '';

        // Add event listeners for the voice button
        if (voiceButton && journalContent) {
            voiceButton.addEventListener('click', toggleSpeechRecognition);
        }

        // Function to toggle speech recognition on/off
        function toggleSpeechRecognition() {
            if (isListening) {
                // Stop listening
                recognition.stop();
                isListening = false;
                voiceButton.classList.remove('active');
                statusDiv.classList.add('d-none');

                // Update button
                voiceButton.innerHTML = '<i class="bi bi-mic"></i>';
                voiceButton.title = 'Start Voice Input (Click again to stop)';
            } else {
                // If there's existing content, preserve it and add a space
                if (journalContent.value && !journalContent.value.endsWith(' ')) {
                    finalTranscript = journalContent.value + ' ';
                } else {
                    finalTranscript = journalContent.value;
                }

                // Start listening
                try {
                    recognition.start();
                    isListening = true;
                    voiceButton.classList.add('active');
                    statusDiv.classList.remove('d-none');

                    // Update button
                    voiceButton.innerHTML = '<i class="bi bi-mic-fill"></i>';
                    voiceButton.title = 'Stop Voice Input';

                    console.log('Speech recognition started');
                } catch (err) {
                    console.error('Speech recognition error:', err);
                    alert('Could not start speech recognition. Please try again.');
                }
            }
        }

        // Handle results
        recognition.onresult = function(event) {
            let interimTranscript = '';

            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript;

                if (event.results[i].isFinal) {
                    finalTranscript += transcript + ' ';
                } else {
                    interimTranscript += transcript;
                }
            }

            // Update textarea with the transcript
            journalContent.value = finalTranscript + interimTranscript;

            // Auto-scroll to the bottom of the textarea
            journalContent.scrollTop = journalContent.scrollHeight;

            // Update word count in status
            const wordCount = journalContent.value.trim().split(/\s+/).filter(Boolean).length;
            statusText.textContent = `Listening... ${wordCount} words recorded. Click mic button again to stop.`;
        };

        // Handle errors
        recognition.onerror = function(event) {
            console.error('Speech recognition error:', event.error);

            // If error is not 'aborted' (which happens on normal stop)
            if (event.error !== 'aborted') {
                // Special handling for permission errors
                if (event.error === 'not-allowed') {
                    // Create a more helpful error message for permission issues
                    const errorMessage = `
                        <div class="alert alert-warning" role="alert">
                            <h5><i class="bi bi-exclamation-triangle-fill"></i> Microphone Access Required</h5>
                            <p>Please allow microphone access in your browser to use the voice input feature.</p>
                            <p><strong>How to fix this:</strong></p>
                            <ol>
                                <li>Look for the microphone icon or permission dialog in your browser's address bar</li>
                                <li>Click it and select "Allow" for this site</li>
                                <li>Refresh the page and try again</li>
                            </ol>
                        </div>
                    `;

                    // Show as a modal instead of an alert for better UX
                    const modalHtml = `
                        <div class="modal fade" id="micPermissionModal" tabindex="-1" aria-hidden="true">
                            <div class="modal-dialog">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title">Microphone Access Needed</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body">
                                        ${errorMessage}
                                    </div>
                                    <div class="modal-footer">
                                        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">I Understand</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Append modal to body if it doesn't exist
                    if (!document.getElementById('micPermissionModal')) {
                        const modalContainer = document.createElement('div');
                        modalContainer.innerHTML = modalHtml;
                        document.body.appendChild(modalContainer.firstChild);

                        // Initialize and show the modal
                        const modal = new bootstrap.Modal(document.getElementById('micPermissionModal'));
                        modal.show();
                    } else {
                        // If modal already exists, just show it
                        const modal = new bootstrap.Modal(document.getElementById('micPermissionModal'));
                        modal.show();
                    }
                } else {
                    // For other errors, show a simple alert
                    alert(`Speech recognition error: ${event.error}. Please try again.`);
                }

                // Reset state
                isListening = false;
                voiceButton.classList.remove('active');
                statusDiv.classList.add('d-none');
                voiceButton.innerHTML = '<i class="bi bi-mic"></i>';
            }
        };

        // Handle end of recognition
        recognition.onend = function() {
            if (isListening) {
                // If it ended unexpectedly while still in listening mode, restart
                try {
                    recognition.start();
                    console.log('Restarted speech recognition after unexpected end');
                } catch (err) {
                    // If we can't restart, reset the UI
                    console.error('Could not restart speech recognition:', err);
                    isListening = false;
                    voiceButton.classList.remove('active');
                    statusDiv.classList.add('d-none');
                    voiceButton.innerHTML = '<i class="bi bi-mic"></i>';
                }
            }
        };
    }

    // Function to update the anxiety level display
    function updateAnxietyLabel(value) {
        const anxietyValue = document.getElementById('anxiety-value');
        const anxietyInput = document.getElementById('anxiety-input');

        // Only proceed if the elements exist (they won't in view-only mode)
        if (anxietyValue && anxietyInput) {
            anxietyValue.textContent = value;
            anxietyInput.value = value;

            // Change badge color based on anxiety level
            if (value <= 3) {
                anxietyValue.className = 'badge bg-success';
            } else if (value <= 6) {
                anxietyValue.className = 'badge bg-warning text-dark';
            } else {
                anxietyValue.className = 'badge bg-danger';
            }
        }
    }

    // Function to show voice input tooltip
    function showVoiceInputTooltip() {
        const voiceButton = document.getElementById('voice-input-button');

        if (voiceButton && !localStorage.getItem('voice_tooltip_shown')) {
            // Create tooltip content
            const tooltipHtml = `
                <div class="voice-tooltip">
                    <div class="arrow"></div>
                    <div class="tooltip-content">
                        <p><strong>New!</strong> Try our voice input feature!</p>
                        <p>Click the microphone to speak your journal entry instead of typing.</p>
                        <button class="btn btn-sm btn-primary mt-2" id="voice-tooltip-got-it">Got it!</button>
                    </div>
                </div>
            `;

            // Create tooltip container
            const tooltipContainer = document.createElement('div');
            tooltipContainer.className = 'voice-tooltip-container';
            tooltipContainer.innerHTML = tooltipHtml;

            // Position near the voice button
            const buttonRect = voiceButton.getBoundingClientRect();
            document.body.appendChild(tooltipContainer);

            // Add animation class after a small delay
            setTimeout(() => {
                tooltipContainer.classList.add('visible');
            }, 500);

            // Add event listener to close button
            document.getElementById('voice-tooltip-got-it').addEventListener('click', function() {
                tooltipContainer.classList.remove('visible');
                setTimeout(() =>```python
{
                    tooltipContainer.remove();
                }, 300);
                localStorage.setItem('voice_tooltip_shown', 'true');
            });

            // Also close when clicking outside
            document.addEventListener('click', function closeTooltip(e) {
                if (!tooltipContainer.contains(e.target) && e.target !== voiceButton) {
                    tooltipContainer.classList.remove('visible');
                    setTimeout(() => {
                        tooltipContainer.remove();
                    }, 300);
                    localStorage.setItem('voice_tooltip_shown', 'true');
                    document.removeEventListener('click', closeTooltip);
                }
            });
        }
    }

    // Set up event listeners when document is ready
    // Voice selection and settings functions - Global scope

    // Current voice settings stored in memory
    const voiceSettings = {
        analysis: {
            voice: localStorage.getItem('analysis_voice') || 'shimmer'
        },
        guidance: {
            voice: localStorage.getItem('guidance_voice') || 'shimmer'
        }
    };

    // Voice type options with display names and personality types
    const voiceOptions = [
        { id: 'alloy', name: 'Alloy', description: 'Versatile neutral voice that works well for many contexts', personality: 'Balanced' },
        { id: 'echo', name: 'Echo', description: 'Transparent and clear voice with a friendly tone', personality: 'Friendly' },
        { id: 'fable', name: 'Fable', description: 'Authoritative and wise narrative voice', personality: 'Confident' },
        { id: 'onyx', name: 'Onyx', description: 'Deep and powerful voice with gravitas', personality: 'Authoritative' },
        { id: 'nova', name: 'Nova', description: 'Weighted, easy-going, and bright female voice', personality: 'Encouraging' },
        { id: 'shimmer', name: 'Shimmer', description: 'Gentle and optimistic female voice', personality: 'Supportive' }
    ];

    // Function to open the voice settings modal
    function openVoiceSettingsModal(type) {
        // type can be 'analysis' or 'guidance'
        const modal = document.getElementById('voiceSettingsModal');
        const modalTitle = document.getElementById('voiceSettingsModalLabel');
        const voiceOptionsContainer = modal.querySelector('.voice-options');
        const saveButton = document.getElementById('saveVoiceSettings');

        // Set the title based on the type
        modalTitle.textContent = type === 'analysis' ? 'Analysis Voice Settings' : 'Guidance Voice Settings';

        // Generate card-style radio buttons for each voice option
        voiceOptionsContainer.innerHTML = `
            <div class="voice-cards">
                ${voiceOptions.map(option => {
                    const isSelected = voiceSettings[type].voice === option.id;
                    return `
                        <div class="voice-card ${isSelected ? 'selected' : ''}" data-voice-id="${option.id}">
                            <input type="radio" name="voice-type" id="voice-${option.id}" 
                                   value="${option.id}" ${isSelected ? 'checked' : ''} class="voice-radio">
                            <div class="voice-card-content">
                                <div class="voice-name">${option.name}</div>
                                <div class="voice-personality">${option.personality}</div>
                                <div class="voice-description">${option.description}</div>
                            </div>
                            <div class="selected-indicator">
                                <i class="bi bi-check-circle-fill"></i>
                            </div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;

        // Add click event to the cards
        const voiceCards = voiceOptionsContainer.querySelectorAll('.voice-card');
        voiceCards.forEach(card => {
            card.addEventListener('click', function() {
                // Update selected state visually
                voiceCards.forEach(c => c.classList.remove('selected'));
                this.classList.add('selected');

                // Update radio button
                const radioInput = this.querySelector('input[type="radio"]');
                radioInput.checked = true;
            });
        });

        // Remove any previous event listeners
        saveButton.replaceWith(saveButton.cloneNode(true));

        // Update the save button reference
        const newSaveButton = document.getElementById('saveVoiceSettings');

        // Add event listener for save button
        newSaveButton.addEventListener('click', function() {
            // Get the selected voice
            const selectedVoice = modal.querySelector('input[name="voice-type"]:checked').value;

            // Update voice settings
            voiceSettings[type].voice = selectedVoice;

            // Save to localStorage
            localStorage.setItem(`${type}_voice`, selectedVoice);

            // Close the modal safely
            try {
                const modalInstance = bootstrap.Modal.getInstance(modal);
                if (modalInstance) {
                    modalInstance.hide();
                } else {
                    console.warn("Modal instance not found, trying direct DOM manipulation");
                    // Direct DOM manipulation instead of jQuery
                    modal.classList.remove('show');
                    modal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                    const backdrop = document.querySelector('.modal-backdrop');
                    if (backdrop) backdrop.remove();
                }
            } catch (e) {
                console.error("Error closing modal:", e);
                // Fallback - try to remove modal classes directly
                modal.classList.remove('show');
                modal.style.display = 'none';
                document.body.classList.remove('modal-open');
                const backdrop = document.querySelector('.modal-backdrop');
                if (backdrop) backdrop.remove();
            }
        });

        // Show the modal with error handling
        try {
            // Check if bootstrap is available
            if (typeof bootstrap === 'undefined') {
                console.error("Bootstrap is not defined - falling back to basic display");
                modal.style.display = 'block';
                modal.classList.add('show');
                document.body.classList.add('modal-open');

                // Create backdrop if it doesn't exist
                let backdrop = document.querySelector('.modal-backdrop');
                if (!backdrop) {
                    backdrop = document.createElement('div');
                    backdrop.className = 'modal-backdrop fade show';
                    document.body.appendChild(backdrop);
                }
                return;
            }

            // Normal bootstrap modal initialization
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
        } catch (e) {
            console.error("Error showing voice settings modal:", e);
            // Fallback to basic display
            modal.style.display = 'block';
            modal.classList.add('show');
            document.body.classList.add('modal-open');

            // Add event listeners to close buttons as a fallback
            const closeButtons = modal.querySelectorAll('[data-bs-dismiss="modal"]');
            closeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    modal.style.display = 'none';
                    modal.classList.remove('show');
                    document.body.classList.remove('modal-open');
                    const backdrop = document.querySelector('.modal-backdrop');
                    if (backdrop) backdrop.remove();
                });
            });
        }
    }

    // Function to get the current voice setting for a type
    function getVoiceSetting(type) {
        return voiceSettings[type].voice;
    }

    // Legacy function for backward compatibility
    function setupTTSLanguageSelectors() {
        // Clear old voice settings
        localStorage.removeItem('analysis_voice');
        localStorage.removeItem('guidance_voice');

        // Reset to use Shimmer voice for all
        voiceSettings.analysis.voice = 'shimmer';
        voiceSettings.guidance.voice = 'shimmer';

        // Save the new settings
        localStorage.setItem('analysis_voice', 'shimmer');
        localStorage.setItem('guidance_voice', 'shimmer');

        console.log("Voice settings initialized with Shimmer as default");
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Focus on title field when page loads
        const titleField = document.getElementById('title');
        if (titleField) {
            titleField.focus();
        }

        // Set up language selection for TTS
        setupTTSLanguageSelectors();

        // Set up the voice settings buttons
        const analysisSettingsBtn = document.getElementById('analysis-voice-settings-btn');
        const guidanceSettingsBtn = document.getElementById('guidance-voice-settings-btn');

        // Add event listeners with error handling
        if (analysisSettingsBtn) {
            analysisSettingsBtn.addEventListener('click', function() {
                try {
                    openVoiceSettingsModal('analysis');
                } catch (e) {
                    console.error("Error opening voice settings modal for analysis:", e);
                    alert("We couldn't open the voice settings. Please try refreshing the page.");
                }
            });
        }

        if (guidanceSettingsBtn) {
            guidanceSettingsBtn.addEventListener('click', function() {
                try {
                    openVoiceSettingsModal('guidance');
                } catch (e) {
                    console.error("Error opening voice settings modal for guidance:", e);
                    alert("We couldn't open the voice settings. Please try refreshing the page.");
                }
            });
        }

        // Set up all TTS buttons with error handling
        const miraTtsButtons = document.querySelectorAll('.mira-tts-button');
        const followupTtsButtons = document.querySelectorAll('.followup-tts-button');
        const serverTtsGuidanceButton = document.getElementById('server-tts-guidance-button');

        if (miraTtsButtons) {
            miraTtsButtons.forEach(button => {
                button.addEventListener('click', function() {
                    try {
                        const isNarrativeResponse = button.closest('.chat-content').querySelector('.mb-0').classList.contains('flex-grow-1');
                        if (isNarrativeResponse) {
                            playMiraNarrativeTTS(button);
                        } else {
                            playMiraReflectionTTS(button);
                        }
                    } catch (e) {
                        console.error("Error playing text-to-speech for Mira's response:", e);
                        alert("We couldn't play the audio. Please try again or refresh the page.");
                    }
                });
            });
        }

        if (followupTtsButtons) {
            followupTtsButtons.forEach(button => {
                button.addEventListener('click', function() {
                    try {
                        playMiraFollowupTTS(button);
                    } catch (e) {
                        console.error("Error playing text-to-speech for Mira's followup:", e);
                        alert("We couldn't play the audio. Please try again or refresh the page.");
                    }
                });
            });
        }

        if (serverTtsGuidanceButton) {
            serverTtsGuidanceButton.addEventListener('click', function() {
                try {
                    playServerTTSGuidance();
                } catch (e) {
                    console.error("Error playing text-to-speech for guidance:", e);
                    alert("We couldn't play the audio. Please try again or refresh the page.");
                }
            });
        }

        // Set the initial anxiety level (only if we're in edit mode)
        const anxietySlider = document.getElementById('anxiety-slider');
        if (anxietySlider) {
            const sliderValue = anxietySlider.value;
            updateAnxietyLabel(sliderValue);
        }

        // Set up the form handling with spinner
        const journalForm = document.getElementById('journal-form');
        const submitButton = document.getElementById('journal-submit-button');

        if (journalForm && submitButton) {
            journalForm.addEventListener('submit', function(event) {
                // Check if form is valid before showing spinner
                if (journalForm.checkValidity()) {
                    // Replace button content with spinner and text
                    submitButton.innerHTML = '<div class="d-flex align-items-center justify-content-center"><span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving...</div>';
                    submitButton.disabled = true;

                    // Debug log
                    console.log('Showing spinner on journal submit');
                }
            });
        }

        // Setup voice input functionality
        setupVoiceInput();

        // Show voice input tooltip after a delay
        setTimeout(showVoiceInputTooltip, 1500);

        // Set up the analyze button with spinner
        const analyzeButton = document.getElementById('analyze-entry');
        if (analyzeButton) {
            analyzeButton.addEventListener('click', function() {
                // Safely get the journal ID with fallback
                let journalId;
                try {
                    journalId = this.getAttribute('data-journal-id');
                    // Verify we have a valid ID
                    if (!journalId || journalId === 'None' || journalId === '') {
                        // Try to get from URL as fallback
                        const urlParts = window.location.pathname.split('/');
                        journalId = urlParts[urlParts.length - 1];
                    }
                } catch (err) {
                    console.error('Error getting journal ID:', err);
                    // Fallback to URL
                    const urlParts = window.location.pathname.split('/');
                    journalId = urlParts[urlParts.length - 1];
                }

                console.log('Using journal ID for analysis:', journalId);

                // Show spinner in button
                this.innerHTML = '<div class="d-flex align-items-center justify-content-center"><span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Analyzing...</div>';
                this.disabled = true;

                // Call API to analyze entry
                fetch(`/api/analyze-entry/${journalId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Reload the page to show new analysis
                            window.location.reload();
                        } else {
                            alert('Error analyzing entry: ' + data.error);
                            // Reset button
                            this.innerHTML = '<i class="bi bi-lightbulb"></i> Analyze My Entry';
                            this.disabled = false;
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred during analysis. Please try again.');
                        // Reset button
                        this.innerHTML = '<i class="bi bi-lightbulb"></i> Analyze My Entry';
                        this.disabled = false;
                    });
            });
        }

        // Set up the ask coach button with spinner
        const coachButton = document.getElementById('ask-coach');
        if (coachButton) {
            coachButton.addEventListener('click', function() {
                // Safely get the journal ID with fallback
                let journalId;
                try {
                    journalId = this.getAttribute('data-journal-id');
                    // Verify we have a valid ID
                    if (!journalId || journalId === 'None' || journalId === '') {
                        // Try to get from URL as fallback
                        const urlParts = window.location.pathname.split('/');
                        journalId = urlParts[urlParts.length - 1];
                    }
                } catch (err) {
                    console.error('Error getting journal ID for coach:', err);
                    // Fallback to URL
                    const urlParts = window.location.pathname.split('/');
                    journalId = urlParts[urlParts.length - 1];
                }

                console.log('Using journal ID for coach:', journalId);

                // Show spinner in button
                this.innerHTML = '<div class="d-flex align-items-center justify-content-center"><span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Asking Mira...</div>';
                this.disabled = true;

                // Call API to get coaching
                fetch(`/api/journal-coach/${journalId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Show coach response area and populate it
                            document.getElementById('coach-response').style.display = 'block';
                            const coachMessage = document.getElementById('coach-message');

                            // Check if we have structured data
                            if (data.structured_data) {
                                // Render structured format
                                let structuredHtml = '';
                                const structData = data.structured_data;

                                // Introduction section
                                if (structData.intro) {
                                    structuredHtml += `<div class="coach-intro mb-4">${structData.intro}</div>`;
                                }

                                // Thought patterns section
                                if (structData.distortions && structData.distortions.length > 0) {
                                    structuredHtml += `<div class="distortions mb-4">
                                        <h5 class="mt-4 mb-3">Thought Patterns</h5>
                                        <ul class="list-group">`;
                                    structData.distortions.forEach(distortion => {
                                        structuredHtml += `<li class="list-group-item">
                                            <strong>${distortion.pattern}</strong>: ${distortion.description}
                                        </li>`;
                                    });
                                    structuredHtml += `</ul></div>`;
                                }

                                // Strategies section
                                if (structData.strategies && structData.strategies.length > 0) {
                                    structuredHtml += `<div class="strategies mb-4">
                                        <h5 class="mt-4 mb-3">CBT Strategies</h5>
                                        <div class="strategy-cards">`;
                                    structData.strategies.forEach(strategy => {
                                        structuredHtml += `<div class="card mb-3">
                                            <div class="card-body">
                                                <h6 class="card-title text-primary">${strategy.title}</h6>
                                                <p>${strategy.description}</p>
                                                ${strategy.action_step ? `<div class="action-step mt-2">
                                                    <strong class="text-dark" style="background-color: #f0f0f0; padding: 2px 5px; border-radius: 3px; display: inline-block;">Try this:</strong> ${strategy.action_step}
                                                </div>` : ''}
                                            </div>
                                        </div>`;
                                    });
                                    structuredHtml += `</div></div>`;
                                }

                                // Reflection prompt
                                if (structData.reflection_prompt) {
                                    structuredHtml += `<div class="reflection-prompt mb-4">
                                        <h5 class="mt-4 mb-3">Reflection Prompt</h5>
                                        <blockquote class="blockquote">
                                            <p class="mb-0">${structData.reflection_prompt}</p>
                                        </blockquote>
                                    </div>`;
                                }

                                // Outro
                                if (structData.outro) {
                                    structuredHtml += `<div class="coach-outro mt-4">${structData.outro}</div>`;
                                }

                                // Add signature if not in outro
                                if (!structuredHtml.includes("Warmly,") && !structuredHtml.includes("Coach Mira")) {
                                    structuredHtml += `<div class="coach-signature mt-3">Warmly,<br>Coach Mira</div>`;
                                }

                                coachMessage.innerHTML = `<div class="coach-insights structured-insights">${structuredHtml}</div>`;
                            } else {
                                // Apply the same CSS as the main response for legacy format
                                let responseText = data.response;
                                // Add signature if it doesn't already exist
                                if (!responseText.includes("Warmly,") && !responseText.includes("Coach Mira")) {
                                    responseText += "\n\nWarmly,\nCoach Mira";
                                }
                                coachMessage.innerHTML = `<div class="coach-insights">${responseText}</div>`;
                            }

                            coachMessage.style.color = 'black';
                            coachMessage.style.backgroundColor = 'white';

                            // Make sure the read aloud buttons are visible
                            const readGuidanceButton = document.getElementById('read-guidance');
                            const stopGuidanceButton = document.getElementById('stop-guidance');
                            if (readGuidanceButton && stopGuidanceButton) {
                                readGuidanceButton.style.display = 'inline-block';
                                stopGuidanceButton.style.display = 'none';
                            }

                            // Reset button
                            this.innerHTML = '<i class="bi bi-chat-dots"></i> Ask Mira Again';
                            this.disabled = false;

                            // Scroll to response
                            document.getElementById('coach-response').scrollIntoView({
                                behavior: 'smooth',
                                block: 'start'
                            });
                        } else {
                            alert('Error getting coaching: ' + data.error);
                            // Reset button
                            this.innerHTML = '<i class="bi bi-chat-dots"></i> Ask Mira for Personalized Guidance';
                            this.disabled = false;
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while asking Mira. Please try again.');
                        // Reset button
                        this.innerHTML = '<i class="bi bi-chat-dots"></i> Ask Mira for Personalized Guidance';
                        this.disabled = false;
                    });
            });
        }

        // Set up the refresh analysis button
        const refreshButton = document.getElementById('refresh-analysis');
        if (refreshButton) {
            refreshButton.addEventListener('click', function() {
                // Safely get the journal ID with fallback
                let journalId;
                try {
                    journalId = this.getAttribute('data-journal-id');
                    // Verify we have a valid ID
                    if (!journalId || journalId === 'None' || journalId === '') {
                        // Try to get from URL as fallback
                        const urlParts = window.location.pathname.split('/');
                        journalId = urlParts[urlParts.length - 1];
                    }
                } catch (err) {
                    console.error('Error getting journal ID for refresh:', err);
                    // Fallback to URL
                    const urlParts = window.location.pathname.split('/');
                    journalId = urlParts[urlParts.length - 1];
                }

                console.log('Using journal ID for refresh:', journalId);

                // Show spinner in button
                this.innerHTML = '<div class="d-flex align-items-center justify-content-center"><span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing...</div>';
                this.disabled = true;

                // Call API to analyze entry
                fetch(`/api/analyze-entry/${journalId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Reload the page to show new analysis
                            window.location.reload();
                        } else {
                            alert('Error refreshing analysis: ' + data.error);
                            // Reset button
                            this.innerHTML = '<i class="bi bi-arrow-repeat"></i> Refresh Analysis';
                            this.disabled = false;
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred during refresh. Please try again.');
                        // Reset button
                        this.innerHTML = '<i class="bi bi-arrow-repeat"></i> Refresh Analysis';
                        this.disabled = false;
                    });
            });
        }

        // Set up text-to-speech functionality
        setupTextToSpeech();
    });

    // Text-to-speech functionality
    function setupTextToSpeech() {
        // Check if browser supports speech synthesis
        if (!('speechSynthesis' in window)) {
            console.log('Text-to-speech not supported in this browser');
            const readButtons = document.querySelectorAll('#read-analysis, #read-guidance');
            readButtons.forEach(button => {
                if (button) {
                    button.style.display = 'none';
                }
            });
            return;
        }

        // Variables to keep track of the current speech state
        let speechSynthesis = window.speechSynthesis;
        let speaking = false;
        let currentUtterance = null;

        // Function to get the best voice - defined at this scope to be accessible to onvoiceschanged
        function getBestVoice() {
            const voices = speechSynthesis.getVoices();

            // No voices available
            if (!voices || voices.length === 0) {
                return null;
            }

            // Premium quality voices first (typically more natural sounding)
            const highQualityVoices = [
                // macOS/iOS voices (very natural sounding)
                "Samantha", "Ava", "Allison", "Victoria", "Susan", "Karen", "Moira",
                // Windows neural voices
                "Microsoft Aria Online (Natural)", "Microsoft Jenny Online (Natural)", 
                "Microsoft Guy Online (Natural)", "Microsoft Christopher Online (Natural)",
                // Standard Windows voices
                "Microsoft Zira", "Microsoft Linda", "Microsoft Catherine", "Microsoft David",
                // Google voices
                "Google UK English Female", "Google US English", 
                // Amazon Polly voices (if available in browser)
                "Joanna", "Ivy", "Kendra", "Kimberly", "Salli", "Matthew", "Brian"
            ];

            // Log available voices for debugging
            console.log("Speech synthesis voices loaded. Available voices:", voices.length);
            console.log("Available voices:");
            voices.forEach((voice, index) => {
                console.log(`${index + 1}. ${voice.name} (${voice.lang})${voice.default ? ' - DEFAULT' : ''}`);
            });

            // Try to identify the selected voice
            let selectedVoice = null;

            // Try to find high-quality English voices first
            for (const voiceName of highQualityVoices) {
                const foundVoice = voices.find(v => 
                    v.name === voiceName || 
                    v.name.includes(voiceName)
                );
                if (foundVoice) {
                    return foundVoice;
                }
            }

            // If no specific high-quality voice is found, try by more general criteria
            // First, try to find any premium/enhanced/neural voice for English
            const premiumVoice = voices.find(voice => 
                (voice.name.toLowerCase().includes('premium') || 
                 voice.name.toLowerCase().includes('enhanced') ||
                 voice.name.toLowerCase().includes('neural') ||
                 voice.name.toLowerCase().includes('natural')) &&
                (voice.lang.startsWith('en-'))
            );

            if (premiumVoice) {
                return premiumVoice;
            }

            // Next, try to find any female English voice
            const femaleVoice = voices.find(voice => 
                (voice.name.toLowerCase().includes('female') || 
                 voice.name.toLowerCase().includes('woman') || 
                 voice.name.toLowerCase().includes('girl') ||
                 voice.name.toLowerCase().includes('samantha') || 
                 voice.name.toLowerCase().includes('victoria') ||
                 voice.name.toLowerCase().includes('karen') ||
                 voice.name.toLowerCase().includes('moira')) &&
                (voice.lang.startsWith('en-'))
            );

            if (femaleVoice) {
                return femaleVoice;
            }

            // Fall back to any English voice
            const englishVoice = voices.find(voice => voice.lang.startsWith('en-'));
            if (englishVoice) {
                return englishVoice;
            }

            // Fall back to the default voice
            return voices[0];
        }

        // Set up speech for the main analysis
        const readAnalysisButton = document.getElementById('read-analysis');
        const stopAnalysisButton = document.getElementById('stop-reading');

        if (readAnalysisButton && stopAnalysisButton) {
            // Get the content to read
            const analysisContent = document.querySelector('.coach-insights');

            readAnalysisButton.addEventListener('click', function() {
                if (speaking) {
                    // If something else is already being read, stop it first
                    speechSynthesis.cancel();
                    resetAllSpeechButtons();
                }

                // Start reading the analysis
                if (analysisContent) {
                    speakText(analysisContent.textContent);

                    // Update UI
                    readAnalysisButton.style.display = 'none';
                    stopAnalysisButton.style.display = 'inline-block';
                    speaking = true;
                }
            });

            stopAnalysisButton.addEventListener('click', function() {
                // Stop reading
                speechSynthesis.cancel();

                // Update UI
                stopAnalysisButton.style.display = 'none';
                readAnalysisButton.style.display = 'inline-block';
                speaking = false;
                currentUtterance = null;
            });
        }

        // Set up speech for the personalized guidance
        const readGuidanceButton = document.getElementById('read-guidance');
        const stopGuidanceButton = document.getElementById('stop-guidance');

        if (readGuidanceButton && stopGuidanceButton) {
            readGuidanceButton.addEventListener('click', function() {
                if (speaking) {
                    // If something else is already being read, stop it first
                    speechSynthesis.cancel();
                    resetAllSpeechButtons();
                }

                // Get the content to read
                const guidanceContent = document.getElementById('coach-message');

                if (guidanceContent) {
                    // For structured data, we want to combine all the text in a logical order
                    let textToRead = '';
                    const structuredData = guidanceContent.querySelector('.structured-insights');

                    if (structuredData) {
                        // Get intro
                        const intro = structuredData.querySelector('.intro');
                        if (intro) textToRead += intro.textContent + ' ';

                        // Get thought patterns
                        const patterns = structuredData.querySelector('.distortions');
                        if (patterns) {
                            textToRead += 'Thought Patterns: ';
                            const patternItems = patterns.querySelectorAll('li');
                            patternItems.forEach(item => {
                                textToRead += item.textContent + '. ';
                            });
                        }

                        // Get strategies
                        const strategies = structuredData.querySelector('.strategies');
                        if (strategies) {
                            textToRead += 'CBT Strategies: ';
                            const strategyItems = strategies.querySelectorAll('.card');
                            strategyItems.forEach(item => {
                                const title = item.querySelector('.card-title');
                                const description = item.querySelector('p');
                                const actionStep = item.querySelector('.action-step');

                                if (title) textToRead += title.textContent + ': ';
                                if (description) textToRead += description.textContent + ' ';
                                if (actionStep) textToRead += actionStep.textContent + '. ';
                            });
                        }

                        // Get reflection prompt
                        const reflectionPrompt = structuredData.querySelector('.reflection-prompt');
                        if (reflectionPrompt) {
                            textToRead += 'Reflection Prompt: ';
                            const promptText = reflectionPrompt.querySelector('p');
                            if (promptText) textToRead += promptText.textContent + '. ';
                        }

                        // Get outro
                        const outro = structuredData.querySelector('.outro');
                        if (outro) textToRead += outro.textContent + ' ';

                        // Add signature if not present
                        if (!textToRead.includes('Warmly') && !textToRead.includes('Coach Mira')) {
                            textToRead += 'Warmly, Coach Mira';
                        }
                    } else {
                        // Use the entire content for legacy responses
                        textToRead = guidanceContent.textContent;
                    }

                    speakText(textToRead);

                    // Update UI
                    readGuidanceButton.style.display = 'none';
                    stopGuidanceButton.style.display = 'inline-block';
                    speaking = true;
                }
            });

            stopGuidanceButton.addEventListener('click', function() {
                // Stop reading
                speechSynthesis.cancel();

                // Update UI
                stopGuidanceButton.style.display = 'none';
                readGuidanceButton.style.display = 'inline-block';
                speaking = false;
                currentUtterance = null;
            });
        }

        // Function to reset all speech buttons to their initial state
        function resetAllSpeechButtons() {
            // Reset analysis buttons
            if (readAnalysisButton && stopAnalysisButton) {
                readAnalysisButton.style.display = 'inline-block';
                stopAnalysisButton.style.display = 'none';
            }

            // Reset guidance buttons
            if (readGuidanceButton && stopGuidanceButton) {
                readGuidanceButton.style.display = 'inline-block';
                stopGuidanceButton.style.display = 'none';
            }

            speaking = false;
            currentUtterance = null;
        }

        // Function to speak text with good settings for reading coaching content
        function speakText(text) {
            // Clean the text - remove extra whitespace and HTML tags
            text = text.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();

            // Advanced text preprocessing for more natural sounding speech

            // Add explicit speech breaks using SSML-like patterns for better naturalness
            // We'll use commas as the natural break points in speech synthesis

            // Step 1: Process emphasized text and quotes with appropriate pauses and intonation
            text = text
                .replace(/\"([^\"]+)\"/g, (match, p1) => '. . "' + p1 + '". . ') // Add longer pauses around quotes with double break
                .replace(/\*([^\*]+)\*/g, (match, p1) => ' ! ' + p1.toUpperCase() + ' ! ') // Capitalize and emphasize *text*
                .replace(/\b(important|remember|note)\b/gi, (match) => '. . ' + match.toUpperCase() + '. . '); // Emphasize key words

            // Step 2: Improve sentence and phrase boundaries with strategic pauses
            text = text
                .replace(/\.\s+/g, '. . . ') // Add a longer pause after periods (end of sentences)
                .replace(/\?\s+/g, '? . . ') // Add a slightly longer pause after questions for contemplation
                .replace(/!\s+/g, '! . . ')  // Add a slightly longer pause after exclamations for impact
                .replace(/:\s+/g, ': , ')    // Add a medium pause after colons
                .replace(/;\s+/g, '; , ')    // Add a medium pause after semicolons
                .replace(/\s-\s/g, ' , - , ') // Add pauses around dashes used as breaks
                .replace(/(\.\.\.)(\s|$)/g, '. . . $2'); // Make ellipses more distinct

            // Step 3: Make commas produce actual pauses
            text = text
                .replace(/,\s+/g, ', ') // Ensure proper pause after commas
                .replace(/,/g, ' , ');   // Turn all commas into pauses with spaces

            // Step 4: Handle lists and structured content for better readability
            text = text
                .replace(/(\d+\.\s+|\-\s+|\\s+)/g, ' . . $1 ') // Add pause before list items
                .replace(/(Step \d+):/g, ' . . $1 , ') // Add emphasis to step numbers
                .replace(/\b(First|Second|Third|Fourth|Fifth|Finally)\b/g, ' . . $1 , ') // Add pause before sequence markers

            // Create utterance and configure it for a more natural sound
            const utterance = new SpeechSynthesisUtterance(text);

            // Voice quality improvement settings
            utterance.rate = 0.82;    // Slightly slower for better comprehension
            utterance.pitch = 1.05;   // Slight pitch adjustment for more warmth
            utterance.volume = 1.0;   // Full volume

            // Advanced settings to improve naturalness (where supported)
            try {
                // Try to apply SSML-inspired enhancements for supported browsers
                // These are non-standard but work in some browsers

                // @ts-ignore: Property may not exist on type SpeechSynthesisUtterance
                if (typeof utterance.voiceURI !== 'undefined') {
                    // Try to use a higher quality voice URI
                    utterance.voiceURI = 'premium';
                }

                // Chrome and Edge can sometimes benefit from these Speech Synthesis properties
                // Access non-standard properties safely

                // Some browsers support pitch contour for more expressive speech
                if (typeof utterance.pitchContour !== 'undefined') {
                    utterance.pitchContour = [
                        [0, -2],   // Start slightly lower
                        [0.33, 2],  // Rise in the middle
                        [0.66, 0],  // Return to normal
                        [1, -1]     // End slightly lower
                    ];
                }

                // Some Microsoft Edge versions support these
                try {
                    // Access non-standard properties only available in some browsers
                    if (utterance.prosody) {
                        utterance.prosody = {
                            rate: 'medium',
                            pitch: 'medium',
                            volume: 'loud'
                        };
                    }
                } catch (e) {
                    // Ignore error - this property doesn't exist on this browser
                }

                // Try to influence the conversation style (Microsoft Edge)
                try {
                    // Access non-standard properties only available in Edge
                    if (utterance.style) {
                        utterance.style = 'conversational';
                    }
                } catch (e) {
                    // Ignore error - this property doesn't exist on this browser
                }
            } catch (e) {
                console.log('Advanced speech settings not supported:', e);
            }

            // Use the best available voice from our prioritized list
            const bestVoice = getBestVoice();
            if (bestVoice) {
                utterance.voice = bestVoice;
                console.log('Using voice: ' + bestVoice.name);
            }

            // Handle the end of speech
            utterance.onend = function() {
                speaking = false;
                resetAllSpeechButtons();
                console.log('Speech completed');
            };

            // Handle errors
            utterance.onerror = function(event) {
                console.error('Speech synthesis error:', event.error);
                speaking = false;
                resetAllSpeechButtons();
            };

            // Start speaking
            currentUtterance = utterance;
            speechSynthesis.speak(utterance);

            // Chrome has a bug where it stops speaking after ~15 seconds
            // This is a workaround to keep it going
            const resumeTimer = setInterval(function() {
                if (speaking && speechSynthesis.paused) {
                    speechSynthesis.resume();
                }

                // Clear the interval when speech is done
                if (!speaking) {
                    clearInterval(resumeTimer);
                }
            }, 5000);
        }

        // Handle page visibility changes to prevent speech continuing when the user navigates away
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState !== 'visible' && speaking) {
                speechSynthesis.cancel();
                resetAllSpeechButtons();
            }
        });

        // Load voices when they are available (needed for some browsers)
        speechSynthesis.onvoiceschanged = function() {
            const voices = speechSynthesis.getVoices();
            console.log('Speech synthesis voices loaded. Available voices:', voices.length);

            // Log the available voices for debugging
            if (voices.length > 0) {
                console.log('Available voices:');
                voices.forEach((voice, index) => {
                    console.log(`${index + 1}. ${voice.name} (${voice.lang})${voice.default ? ' - DEFAULT' : ''}`);
                });

                // Show which voice would be selected by our algorithm
                const selectedVoice = getBestVoice();
                if (selectedVoice) {
                    console.log('Selected voice:', selectedVoice.name);
                }
            }
        };

        // Initialize voices
        speechSynthesis.getVoices();
    }

    // TTS function for Mira's narrative response
    function playMiraNarrativeTTS(button) {
        // Get the narrative response text
        const text = button.closest('.d-flex').querySelector('.mb-0').textContent.trim();
        const audio = document.getElementById('serverAudio');

        // Get the selected voice from our settings (using OpenAI voices)
        const selectedVoice = getVoiceSetting('analysis');

        // Show loading state
        button.disabled = true;
        button.innerHTML = '<i class="bi bi-hourglass-split"></i>';

        // Reset audio
        audio.pause();
        audio.src = '';

        // Prepare request data
        const requestData = {
            text: text,
            voice: selectedVoice
        };

        // Display error message with more detail
        function displayErrorMessage(message) {
            // Create error container if it doesn't exist
            let errorContainer = document.getElementById('tts-error-message');
            if (!errorContainer) {
                errorContainer = document.createElement('div');
                errorContainer.id = 'tts-error-message';
                errorContainer.className = 'alert alert-danger mt-2';
                errorContainer.style.fontSize = '0.9rem';
                audio.parentNode.insertBefore(errorContainer, audio.nextSibling);
            }

            errorContainer.innerHTML = `<i class="bi bi-exclamation-triangle"></i> ${message}`;
            errorContainer.style.display = 'block';

            // Auto-hide after 10 seconds
            setTimeout(() => {
                errorContainer.style.display = 'none';
            }, 10000);
        }

        // Set a timeout to prevent indefinite loading
        const timeoutId = setTimeout(() => {
            // If it's been more than 15 seconds, abort and reset
            if (button.disabled) {
                console.log('TTS request timed out after 15 seconds');
                button.disabled = false;
                button.innerHTML = '<i class="bi bi-volume-up"></i>';
                displayErrorMessage('Voice generation timed out. Please try again or select a different voice.');
            }
        }, 15000);

        // Request TTS using the OpenAI TTS endpoint
        fetch('/api/openai-tts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        })
        .then(response => {
            // Clear the timeout since we got a response
            clearTimeout(timeoutId);

            if (!response.ok) {
                return response.json().then(data => {
                    // Get specific error message from the server if available
                    const errorMessage = data.error || 'Unknown server error';
                    throw new Error(errorMessage);
                }).catch(e => {
                    // If can't parse JSON from error response
                    throw new Error(`Server error (${response.status}): ${response.statusText}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log("OpenAI TTS response:", data);

            // Hide any previous error message
            const errorContainer = document.getElementById('tts-error-message');
            if (errorContainer) {
                errorContainer.style.display = 'none';
            }

            // Set the audio source to the URL returned by the server
            audio.src = data.audio_url;
            audio.style.display = 'block';

            // Reset button state
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-volume-up"></i>';

            // Play the audio
            audio.play();
        })
        .catch(error => {
            // Clear the timeout since we got a response (error)
            clearTimeout(timeoutId);

            console.error('Error generating speech:', error);
            // Reset button state
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-volume-up"></i>';

            // Show specific error message based on the error
            let errorMessage = 'Sorry, there was a problem generating the audio.';

            if (error.message.includes('API key')) {
                errorMessage = 'Voice service configuration issue. Please try again later or contact support.';
            } else if (error.message.includes('rate limit')) {
                errorMessage = 'Voice service is temporarily unavailable due to high demand. Please try again in a few minutes.';
            } else if (error.message.includes('Network')) {
                errorMessage = 'Network connection issue. Please check your internet connection and try again.';
            } else if (error.message.includes('timed out')) {
                errorMessage = 'Voice generation timed out. Please try again or select a different voice.';
            }

            displayErrorMessage(errorMessage);
        });
    }

    // TTS function for Mira's reflection prompt
    function playMiraReflectionTTS(button) {
        // Get the reflection prompt text
        const text = button.closest('.d-flex').querySelector('.reflection-prompt').textContent.trim();
        const audio = document.getElementById('serverAudio');

        // Get the selected voice from our settings
        const selectedVoice = getVoiceSetting('analysis');

        // Show loading state
        button.disabled = true;
        button.innerHTML = '<i class="bi bi-hourglass-split"></i>';

        // Reset audio
        audio.pause();
        audio.src = '';

        // Prepare request data
        const requestData = {
            text: text,
            voice: selectedVoice
        };

        // Display error message with more detail
        function displayErrorMessage(message) {
            // Create error container if it doesn't exist
            let errorContainer = document.getElementById('tts-error-message');
            if (!errorContainer) {
                errorContainer = document.createElement('div');
                errorContainer.id = 'tts-error-message';
                errorContainer.className = 'alert alert-danger mt-2';
                errorContainer.style.fontSize = '0.9rem';
                audio.parentNode.insertBefore(errorContainer, audio.nextSibling);
            }

            errorContainer.innerHTML = `<i class="bi bi-exclamation-triangle"></i> ${message}`;
            errorContainer.style.display = 'block';

            // Auto-hide after 10 seconds
            setTimeout(() => {
                errorContainer.style.display = 'none';
            }, 10000);
        }

        // Set a timeout to prevent indefinite loading
        const timeoutId = setTimeout(() => {
            // If it's been more than 15 seconds, abort and reset
            if (button.disabled) {
                console.log('TTS request timed out after 15 seconds');
                button.disabled = false;
                button.innerHTML = '<i class="bi bi-volume-up"></i>';
                displayErrorMessage('Voice generation timed out. Please try again or select a different voice.');
            }
        }, 15000);

        // Request TTS using the OpenAI TTS endpoint
        fetch('/api/openai-tts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        })
        .then(response => {
            // Clear the timeout since we got a response
            clearTimeout(timeoutId);

            if (!response.ok) {
                return response.json().then(data => {
                    // Get specific error message from the server if available
                    const errorMessage = data.error || 'Unknown server error';
                    throw new Error(errorMessage);
                }).catch(e => {
                    // If can't parse JSON from error response
                    throw new Error(`Server error (${response.status}): ${response.statusText}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log("OpenAI TTS response:", data);

            // Hide any previous error message
            const errorContainer = document.getElementById('tts-error-message');
            if (errorContainer) {
                errorContainer.style.display = 'none';
            }

            // Set the audio source to the URL returned by the server
            audio.src = data.audio_url;
            audio.style.display = 'block';

            // Reset button state
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-volume-up"></i>';

            // Play the audio
            audio.play();
        })
        .catch(error => {
            // Clear the timeout since we got a response (error)
            clearTimeout(timeoutId);

            console.error('Error generating speech:', error);
            // Reset button state
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-volume-up"></i>';

            // Show specific error message based on the error
            let errorMessage = 'Sorry, there was a problem generating the audio.';

            if (error.message.includes('API key')) {
                errorMessage = 'Voice service configuration issue. Please try again later or contact support.';
            } else if (error.message.includes('rate limit')) {
                errorMessage = 'Voice service is temporarily unavailable due to high demand. Please try again in a few minutes.';
            } else if (error.message.includes('Network')) {
                errorMessage = 'Network connection issue. Please check your internet connection and try again.';
            } else if (error.message.includes('timed out')) {
                errorMessage = 'Voice generation timed out. Please try again or select a different voice.';
            }

            displayErrorMessage(errorMessage);
        });
    }

    // TTS function for Mira's followup message
    function playMiraFollowupTTS(button) {
        // Get the followup text
        const text = button.closest('.d-flex').querySelector('.mb-0').textContent.trim();
        const audio = document.getElementById('serverAudio');

        // Get the selected voice from our settings
        const selectedVoice = getVoiceSetting('analysis');

        // Show loading state
        button.disabled = true;
        button.innerHTML = '<i class="bi bi-hourglass-split"></i>';

        // Reset audio
        audio.pause();
        audio.src = '';

        // Prepare request data
        const requestData = {
            text: text,
            voice: selectedVoice
        };

        // Display error message with more detail
        function displayErrorMessage(message) {
            // Create error container if it doesn't exist
            let errorContainer = document.getElementById('tts-error-message');
            if (!errorContainer) {
                errorContainer = document.createElement('div');
                errorContainer.id = 'tts-error-message';
                errorContainer.className = 'alert alert-danger mt-2';
                errorContainer.style.fontSize = '0.9rem';
                audio.parentNode.insertBefore(errorContainer, audio.nextSibling);
            }

            errorContainer.innerHTML = `<i class="bi bi-exclamation-triangle"></i> ${message}`;
            errorContainer.style.display = 'block';

            // Auto-hide after 10 seconds
            setTimeout(() => {
                errorContainer.style.display = 'none';
            }, 10000);
        }

        // Set a timeout to prevent indefinite loading
        const timeoutId = setTimeout(() => {
            // If it's been more than 15 seconds, abort and reset
            if (button.disabled) {
                console.log('TTS request timed out after 15 seconds');
                button.disabled = false;
                button.innerHTML = '<i class="bi bi-volume-up"></i>';
                displayErrorMessage('Voice generation timed out. Please try again or select a different voice.');
            }
        }, 15000);

        // Request TTS using the OpenAI TTS endpoint
        fetch('/api/openai-tts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        })
        .then(response => {
            // Clear the timeout since we got a response
            clearTimeout(timeoutId);

            if (!response.ok) {
                return response.json().then(data => {
                    // Get specific error message from the server if available
                    const errorMessage = data.error || 'Unknown server error';
                    throw new Error(errorMessage);
                }).catch(e => {
                    // If can't parse JSON from error response
                    throw new Error(`Server error (${response.status}): ${response.statusText}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log("OpenAI TTS response:", data);

            // Hide any previous error message
            const errorContainer = document.getElementById('tts-error-message');
            if (errorContainer) {
                errorContainer.style.display = 'none';
            }

            // Set the audio source to the URL returned by the server
            audio.src = data.audio_url;
            audio.style.display = 'block';

            // Reset button state
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-volume-up"></i>';

            // Play the audio
            audio.play();
        })
        .catch(error => {
            // Clear the timeout since we got a response (error)
            clearTimeout(timeoutId);

            console.error('Error generating speech:', error);
            // Reset button state
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-volume-up"></i>';

            // Show specific error message based on the error
            let errorMessage = 'Sorry, there was a problem generating the audio.';

            if (error.message.includes('API key')) {
                errorMessage = 'Voice service configuration issue. Please try again later or contact support.';
            } else if (error.message.includes('rate limit')) {
                errorMessage = 'Voice service is temporarily unavailable due to high demand. Please try again in a few minutes.';
            } else if (error.message.includes('Network')) {
                errorMessage = 'Network connection issue. Please check your internet connection and try again.';
            } else if (error.message.includes('timed out')) {
                errorMessage = 'Voice generation timed out. Please try again or select a different voice.';
            }

            displayErrorMessage(errorMessage);
        });
    }

    // Legacy Server-side TTS function for Analysis (keeping for compatibility)
    function playServerTTS() {
        // Get the coach response text
        const text = document.querySelector('.coach-insights').textContent.trim();
        const button = document.getElementById('server-tts-button') || document.querySelector('.mira-tts-button');
        const audio = document.getElementById('serverAudio');

        // Get the selected voice from our settings (now using OpenAI voices)
        const selectedVoice = getVoiceSetting('analysis');

        // Show loading state
        if (button) {
            button.disabled = true;
            button.innerHTML = '<i class="bi bi-hourglass-split"></i> Generating neural audio...';
        }

        // Reset audio
        audio.pause();
        audio.src = '';

        // Prepare request data
        const requestData = {
            text: text,
            voice: selectedVoice
        };

        // Display error message with more detail
        function displayErrorMessage(message) {
            // Create error container if it doesn't exist
            let errorContainer = document.getElementById('tts-error-message');
            if (!errorContainer) {
                errorContainer = document.createElement('div');
                errorContainer.id = 'tts-error-message';
                errorContainer.className = 'alert alert-danger mt-2';
                errorContainer.style.fontSize = '0.9rem';
                audio.parentNode.insertBefore(errorContainer, audio.nextSibling);
            }

            errorContainer.innerHTML = `<i class="bi bi-exclamation-triangle"></i> ${message}`;
            errorContainer.style.display = 'block';

            // Auto-hide after 10 seconds
            setTimeout(() => {
                errorContainer.style.display = 'none';
            }, 10000);
        }

        // Set a timeout to prevent indefinite loading
        const timeoutId = setTimeout(() => {
            // If it's been more than 15 seconds, abort and reset
            if (button.disabled && button.innerHTML.includes('Generating')) {
                console.log('TTS request timed out after 15 seconds');
                button.disabled = false;
                button.innerHTML = '<i class="bi bi-cloud"></i> Listen to Mira\'s Response';
                displayErrorMessage('Voice generation timed out. Please try again or select a different voice.');
            }
        }, 15000);

        // Request TTS using the OpenAI TTS endpoint
        fetch('/api/openai-tts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        })
        .then(response => {
            // Clear the timeout since we got a response
            clearTimeout(timeoutId);

            if (!response.ok) {
                return response.json().then(data => {
                    // Get specific error message from the server if available
                    const errorMessage = data.error || 'Unknown server error';
                    throw new Error(errorMessage);
                }).catch(e => {
                    // If can't parse JSON from error response
                    throw new Error(`Server error (${response.status}): ${response.statusText}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log("OpenAI TTS response:", data);

            // Hide any previous error message
            const errorContainer = document.getElementById('tts-error-message');
            if (errorContainer) {
                errorContainer.style.display = 'none';
            }

            // Set the audio source to the URL returned by the server
            audio.src = data.audio_url;
            audio.style.display = 'block';

            // Reset button state
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-cloud-check"></i> Listen to Mira\'s Response';

            // Play the audio
            audio.play();
        })
        .catch(error => {
            // Clear the timeout since we got a response (error)
            clearTimeout(timeoutId);

            console.error('Error generating speech:', error);
            // Reset button state
            button.disabled= false;
            button.innerHTML = '<i class="bi bi-cloud"></i> Listen to Mira\'s Response';

            // Show specific error message based on the error
            let errorMessage = 'Sorry, there was a problem generating the audio.';

            if (error.message.includes('API key')) {
                errorMessage = 'Voice service configuration issue. Please try again later or contact support.';
            } else if (error.message.includes('rate limit')) {
                errorMessage = 'Voice service is temporarily unavailable due to high demand. Please try again in a few minutes.';
            } else if (error.message.includes('Network')) {
                errorMessage = 'Network connection issue. Please check your internet connection and try again.';
            } else if (error.message.includes('timed out')) {
                errorMessage = 'Voice generation timed out. Please try again or select a different voice.';
            }

            displayErrorMessage(errorMessage);
        });
    }

    // Server-side TTS function for Guidance
    function playServerTTSGuidance() {
        // Get the coach message element
        const coachMessage = document.getElementById('coach-message');
        const button = document.getElementById('server-tts-guidance-button');
        const audio = document.getElementById('serverGuidanceAudio');

        // Extract text to read based on whether it's structured or not
        let textToRead = '';
        const structuredData = coachMessage.querySelector('.structured-insights');

        if (structuredData) {
            // For structured data, we want to combine all the text in a logical order

            // Get intro
            const intro = structuredData.querySelector('.intro');
            if (intro) textToRead += intro.textContent + ' ';

            // Get thought patterns
            const patterns = structuredData.querySelector('.distortions');
            if (patterns) {
                textToRead += 'Thought Patterns: ';
                const patternItems = patterns.querySelectorAll('li');
                patternItems.forEach(item => {
                    textToRead += item.textContent + '. ';
                });
            }

            // Get strategies
            const strategies = structuredData.querySelector('.strategies');
            if (strategies) {
                textToRead += 'CBT Strategies: ';
                const strategyItems = strategies.querySelectorAll('.card');
                strategyItems.forEach(item => {
                    const title = item.querySelector('.card-title');
                    const description = item.querySelector('p');
                    const actionStep = item.querySelector('.action-step');

                    if (title) textToRead += title.textContent + ': ';
                    if (description) textToRead += description.textContent + ' ';
                    if (actionStep) textToRead += actionStep.textContent + '. ';
                });
            }

            // Get reflection prompt
            const reflection = structuredData.querySelector('.reflection-prompt');
            if (reflection) {
                textToRead += 'Reflection Prompt: ';
                const promptText = reflection.querySelector('p');
                if (promptText) textToRead += promptText.textContent + '. ';
            }

            // Get outro
            const outro = structuredData.querySelector('.outro');
            if (outro) textToRead += outro.textContent + ' ';

            // Add signature if not present
            if (!textToRead.includes('Warmly') && !textToRead.includes('Coach Mira')) {
                textToRead += 'Warmly, Coach Mira';
            }
        } else {
            // Use the entire content for legacy responses
            textToRead = coachMessage.textContent.trim();
        }

        // Get the selected voice from our settings (now using OpenAI voices)
        const selectedVoice = getVoiceSetting('guidance');

        // Show loading state
        button.disabled = true;
        button.innerHTML = '<i class="bi bi-hourglass-split"></i> Generating neural audio...';

        // Reset audio
        audio.pause();
        audio.src = '';

        // Prepare request data
        const requestData = {
            text: textToRead,
            voice: selectedVoice
        };

        // Display error message with more detail
        function displayErrorMessage(message) {
            // Create error container if it doesn't exist
            let errorContainer = document.getElementById('tts-guidance-error-message');
            if (!errorContainer) {
                errorContainer = document.createElement('div');
                errorContainer.id = 'tts-guidance-error-message';
                errorContainer.className = 'alert alert-danger mt-2';
                errorContainer.style.fontSize = '0.9rem';
                audio.parentNode.insertBefore(errorContainer, audio.nextSibling);
            }

            errorContainer.innerHTML = `<i class="bi bi-exclamation-triangle"></i> ${message}`;
            errorContainer.style.display = 'block';

            // Auto-hide after 10 seconds
            setTimeout(() => {
                errorContainer.style.display = 'none';
            }, 10000);
        }

        // Set a timeout to prevent indefinite loading
        const timeoutId = setTimeout(() => {
            // If it's been more than 15 seconds, abort and reset
            if (button.disabled && button.innerHTML.includes('Generating')) {
                console.log('TTS guidance request timed out after 15 seconds');
                button.disabled = false;
                button.innerHTML = '<i class="bi bi-cloud"></i> Listen to Mira\'s Guidance';
                displayErrorMessage('Voice generation timed out. Please try again or select a different voice.');
            }
        }, 15000);

        // Request TTS using the OpenAI TTS endpoint
        fetch('/api/openai-tts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        })
        .then(response => {
            // Clear the timeout since we got a response
            clearTimeout(timeoutId);

            if (!response.ok) {
                return response.json().then(data => {
                    // Get specific error message from the server if available
                    const errorMessage = data.error || 'Unknown server error';
                    throw new Error(errorMessage);
                }).catch(e => {
                    // If can't parse JSON from error response
                    throw new Error(`Server error (${response.status}): ${response.statusText}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log("OpenAI TTS guidance response:", data);

            // Hide any previous error message
            const errorContainer = document.getElementById('tts-guidance-error-message');
            if (errorContainer) {
                errorContainer.style.display = 'none';
            }

            // Set the audio source to the URL returned by the server
            audio.src = data.audio_url;
            audio.style.display = 'block';

            // Reset button state
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-cloud-check"></i> Listen to Mira\'s Guidance';

            // Play the audio
            audio.play();
        })
        .catch(error => {
            // Clear the timeout since we got a response (error)
            clearTimeout(timeoutId);

            console.error('Error generating speech:', error);
            // Reset button state
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-cloud"></i> Listen to Mira\'s Guidance';

            // Show specific error message based on the error
            let errorMessage = 'Sorry, there was a problem generating the audio.';

            if (error.message.includes('API key')) {
                errorMessage = 'Voice service configuration issue. Please try again later or contact support.';
            } else if (error.message.includes('rate limit')) {
                errorMessage = 'Voice service is temporarily unavailable due to high demand. Please try again in a few minutes.';
            } else if (error.message.includes('Network')) {
                errorMessage = 'Network connection issue. Please check your internet connection and try again.';
            } else if (error.message.includes('timed out')) {
                errorMessage = 'Voice generation timed out. Please try again or select a different voice.';
            }

            displayErrorMessage(errorMessage);
        });
    }

    // Show badge earned modal if available
    document.addEventListener('DOMContentLoaded', function() {
        {% if earned_badge %}
        var badgeModal = new bootstrap.Modal(document.getElementById('badgeEarnedModal'));
        badgeModal.show();
        {% endif %}

        // Setup Reflection Pause functionality
        setupReflectionPause();
    });

    // Reflection Pause Functionality
    function setupReflectionPause() {
        // Get elements
        const reflectionPause = document.getElementById('reflection-pause');
        const followupContent = document.getElementById('followup-content');
        const continueButton = document.getElementById('continue-reflection');
        const userReflectionInput = document.getElementById('user-reflection');

        // Exit if elements don't exist (not a reflective pause entry)
        if (!reflectionPause || !followupContent || !continueButton || !userReflectionInput) {
            console.log('Reflection pause elements not found, skipping setup');
            return;
        }

        console.log('Setting up reflection pause functionality');

        // Add click listener for continue button
        continueButton.addEventListener('click', function() {
            // Get user's reflection
            const userReflection = userReflectionInput.value.trim();
            {% if entry %}
            const entryId = '{{ entry.id }}';

            // Save the reflection
            saveUserReflection(userReflection, entryId);
            {% else %}
            console.log('No entry ID available, reflection cannot be saved');
            {% endif %}

            // Show the followup content with a fade in animation
            followupContent.classList.remove('d-none');
            followupContent.style.opacity = '0';
            followupContent.style.transition = 'opacity 0.5s ease';

            // Use a timeout to ensure the transition is visible
            setTimeout(() => {
                followupContent.style.opacity = '1';
            }, 50);
        });

        // Also reveal content if user presses Enter in the textarea (but allow Shift+Enter for new line)
        userReflectionInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent adding a newline
                continueButton.click(); // Trigger the continue button
            }
        });
    }

    // Function to save user's reflection to the journal entry
    function saveUserReflection(reflection, entryId) {
        // Skip if reflection is empty or entry ID is not valid
        if (!reflection || !entryId) {
            console.log('Empty reflection or missing entry ID, not saving');
            return;
        }

        console.log('Saving reflection for entry', entryId);

        // Get CSRF token - fallback to empty string if not available
        const csrfToken = '{{ csrf_token() }}' || '';

        // Check if entry ID is valid
        if (isNaN(parseInt(entryId))) {
            console.error('Invalid entry ID format:', entryId);
            return;
        }

        const payload = {
            entry_id: parseInt(entryId),
            reflection_text: reflection
        };

        console.log('Sending reflection data:', payload);

        // Make API request
        fetch('/journal/save-reflection', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify(payload)
        })
        .then(response => {
            console.log('Response status:', response.status);
            if (!response.ok) {
                return response.text().then(text => {
                    console.error('Error response:', text);
                    throw new Error('Network response was not ok: ' + response.status);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log('Reflection saved successfully:', data);
        })
        .catch(error => {
            console.error('Error saving reflection:', error);
            // Continue showing the content even if saving failed

            // Attempt to save locally if API fails
            try {
                // Store in localStorage as a fallback
                const fallbackKey = `reflection_${entryId}`;
                localStorage.setItem(fallbackKey,```python
 reflection);
                console.log('Saved reflection to localStorage as fallback');
            } catch (storageError) {
                console.error('Could not save to localStorage:', storageError);
            }
        });
    }

    // Conversation-based journaling functionality
    function setupConversationalJournaling() {
        // Get elements from the page
        const submitReflectionBtn = document.getElementById('submit-reflection');
        const reflectionTextArea = document.getElementById('reflection-text');
        const submitSecondReflectionBtn = document.getElementById('submit-second-reflection');
        const secondReflectionTextArea = document.getElementById('second-reflection-text');

        // Only bind if the elements exist (they'll only exist on certain pages)
        if (submitReflectionBtn && reflectionTextArea) {
            console.log('Setting up initial reflection handler');
            submitReflectionBtn.addEventListener('click', function() {
                saveInitialReflection();
            });
        }

        if (submitSecondReflectionBtn && secondReflectionTextArea) {
            console.log('Setting up second reflection handler');
            submitSecondReflectionBtn.addEventListener('click', function() {
                saveSecondReflection();
            });
        }

        function saveInitialReflection() {
            let reflectionText, entryId;

            try {
                // Add defensive checks for null or undefined elements
                if (!reflectionTextArea) {
                    console.error('Reflection text area not found');
                    return;
                }

                reflectionText = reflectionTextArea.value.trim();
                if (!reflectionText) {
                    alert('Please enter your reflection before continuing.');
                    return;
                }

                // Get the entry ID from the URL
                const urlParts = window.location.pathname.split('/');
                entryId = urlParts[urlParts.length - 1];

                if (!entryId || isNaN(parseInt(entryId))) {
                    console.error('Invalid entry ID format:', entryId);
                    alert('There was an error identifying this journal entry. Please try again or refresh the page.');
                    return;
                }

                console.log('Saving initial reflection for entry:', entryId);
            } catch (err) {
                console.error('Error preparing to save initial reflection:', err);
                alert('There was a problem preparing to save your reflection. Please try again or refresh the page.');
                return;
            }

            // Send the reflection to the server
            fetch('/journal/save-initial-reflection', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken() // Defined elsewhere in the script
                },
                body: JSON.stringify({
                    entry_id: entryId,
                    reflection_text: reflectionText
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Reflection saved successfully:', data);

                // Show the user's reflection
                const reflectionCard = document.getElementById('reflection-card');
                if (reflectionCard) {
                    reflectionCard.classList.remove('d-none');
                }

                // Update the user reflection in the card
                const userReflectionDiv = document.querySelector('.user-reflection');
                if (userReflectionDiv) {
                    userReflectionDiv.innerHTML = reflectionText.replace(/\n/g, '<br>');
                }

                // Show the followup card if it exists
                const followupCard = document.getElementById('followup-card');
                if (followupCard) {
                    followupCard.classList.remove('d-none');
                }

                // If we have followup data from the response, update it
                if (data.followup_insight) {
                    const followupInsightDiv = document.querySelector('.followup-insight');
                    if (followupInsightDiv) {
                        followupInsightDiv.innerHTML = data.followup_insight;
                    }
                }

                // Hide the reflection input
                const reflectionInput = document.querySelector('.reflection-input');
                if (reflectionInput) {
                    reflectionInput.classList.add('d-none');
                }

                // Scroll to the followup card
                if (followupCard) {
                    followupCard.scrollIntoView({ behavior: 'smooth' });
                }
            })
            .catch(error => {
                console.error('Error saving reflection:', error);
                alert('There was a problem saving your reflection. Please try again.');
            });
        }

        function saveSecondReflection() {
            let reflectionText, entryId;

            try {
                // Add defensive checks for null or undefined elements
                if (!secondReflectionTextArea) {
                    console.error('Second reflection text area not found');
                    return;
                }

                reflectionText = secondReflectionTextArea.value.trim();
                if (!reflectionText) {
                    alert('Please enter your response before continuing.');
                    return;
                }

                // Get the entry ID from the URL
                const urlParts = window.location.pathname.split('/');
                entryId = urlParts[urlParts.length - 1];

                if (!entryId || isNaN(parseInt(entryId))) {
                    console.error('Invalid entry ID format:', entryId);
                    alert('There was an error identifying this journal entry. Please try again or refresh the page.');
                    return;
                }

                console.log('Saving second reflection for entry:', entryId);

                // Continue with the fetch request below
            } catch (err) {
                console.error('Error preparing to save second reflection:', err);
                alert('There was a problem preparing to save your reflection. Please try again or refresh the page.');
                return;
            }

            // Send the reflection to the server
            fetch('/journal/save-second-reflection', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken() // Defined elsewhere in the script
                },
                body: JSON.stringify({
                    entry_id: entryId,
                    reflection_text: reflectionText
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Second reflection saved successfully:', data);

                // Show the second reflection card
                const secondReflectionCard = document.getElementById('second-reflection-card');
                if (secondReflectionCard) {
                    secondReflectionCard.classList.remove('d-none');
                }

                // Update the second reflection in the card
                const secondReflectionDiv = document.querySelector('.second-reflection');
                if (secondReflectionDiv) {
                    secondReflectionDiv.innerHTML = reflectionText.replace(/\n/g, '<br>');
                }

                // Show the closing card
                const closingCard = document.getElementById('closing-card');
                if (closingCard) {
                    closingCard.classList.remove('d-none');
                }

                // If we have closing message data from the response, update it
                if (data.closing_message) {
                    const closingMessageDiv = document.querySelector('.closing-message');
                    if (closingMessageDiv) {
                        closingMessageDiv.innerHTML = data.closing_message;
                    }
                }

                // Hide the second reflection input
                const secondReflectionInput = document.querySelector('.second-reflection-input');
                if (secondReflectionInput) {
                    secondReflectionInput.classList.add('d-none');
                }

                // Scroll to the closing card
                if (closingCard) {
                    closingCard.scrollIntoView({ behavior: 'smooth' });
                }
            })
            .catch(error => {
                console.error('Error saving second reflection:', error);
                alert('There was a problem saving your response. Please try again.');
            });
        }

        // Helper function to get CSRF token from meta tag or hidden input
        function getCsrfToken() {
            const metaToken = document.querySelector('meta[name="csrf-token"]');
            if (metaToken) {
                return metaToken.getAttribute('content');
            }

            // If meta tag not found, try to get from hidden input (which is added by {{ form.hidden_tag() }})
            const csrfInput = document.querySelector('input[name="csrf_token"]');
            if (csrfInput) {
                return csrfInput.value;
            }

            // If neither is found, try to get from the form directly
            const form = document.querySelector('form');
            if (form) {
                const hiddenInputs = form.querySelectorAll('input[type="hidden"]');
                for (let input of hiddenInputs) {
                    if (input.name === 'csrf_token') {
                        return input.value;
                    }
                }
            }

            // If still not found, return an empty string and log an error
            console.error('CSRF token not found in meta tag or hidden input');
            return '';
        }
    }

    // Initialize conversation journaling when page loads
    document.addEventListener('DOMContentLoaded', function() {
        setupConversationalJournaling();

        // Handle the reflective pause continue button
        const continueButton = document.getElementById('continue-reflection');
        const reflectionPause = document.getElementById('reflection-pause');
        const followupContent = document.getElementById('followup-content');
        const userReflection = document.getElementById('user-reflection');

        if (continueButton && reflectionPause && followupContent) {
            continueButton.addEventListener('click', function() {
                // Validate that the user has entered a reflection
                if (!userReflection || userReflection.value.trim() === '') {
                    alert('Please enter your reflection before continuing.');
                    return;
                }

                // Hide the reflection pause and show the followup content
                reflectionPause.classList.add('d-none');
                followupContent.classList.remove('d-none');

                // Scroll to the followup content
                followupContent.scrollIntoView({ behavior: 'smooth' });

                // Save the reflection to the journal if needed
                // Note: This could be expanded to an AJAX call to save the reflection
                console.log('User reflection:', userReflection.value);

                // Flash a success message
                const successAlert = document.createElement('div');
                successAlert.className = 'alert alert-success alert-dismissible fade show mt-4';
                successAlert.innerHTML = `
                    <strong>Reflection saved!</strong> Your insights have been recorded.
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                `;
                followupContent.parentNode.insertBefore(successAlert, followupContent);

                // Auto-dismiss the alert after 5 seconds
                setTimeout(() => {
                    successAlert.classList.remove('show');
                    setTimeout(() => {
                        successAlert.remove();
                    }, 150);
                }, 5000);
            });
        }
    });
</script>
{% endblock %}